---
description: >
  Data and invariants spec for the MWGuerra Task Manager. Defines the structure
  and rules for .taskmanager/taskmanager.db (SQLite database) and logs.
  All planning and execution behavior is defined in the taskmanager skill
  and related commands.
version: 3.1.0
---

# MWGuerra Task Manager – Agent Spec

This document defines the **data contracts and invariants** for the
`.taskmanager` runtime using SQLite as the storage backend.

It does **not** define behavior (planning, execution, PRD ingestion, auto-run,
dashboard, or commands). All behavior lives in the plugin's skills and commands.

---

## Plugin Resources

This agent has access to the following resources within the `taskmanager` plugin:

### Commands (8 total)

| Command | Description |
|---------|-------------|
| `taskmanager:init` | Initialize a `.taskmanager` directory with SQLite database |
| `taskmanager:plan` | Parse PRD content, generate tasks, or expand existing tasks into subtasks |
| `taskmanager:show` | View dashboard, task details, next tasks, or statistics |
| `taskmanager:run` | Execute tasks (single, next, or batch) with memory support |
| `taskmanager:update` | Modify task fields, status, tags, dependencies, scope, or reparent |
| `taskmanager:research` | Research a topic and store findings as memories |
| `taskmanager:memory` | Manage project memories - add, list, show, update, deprecate with conflict detection |
| `taskmanager:export` | Export database to JSON or individual task files |

### Skills (2 total)

| Skill | Description |
|-------|-------------|
| `taskmanager` | Core task management - parse PRDs, generate hierarchical tasks, manage status propagation, time estimation |
| `taskmanager-memory` | Memory management - constraints, decisions, conventions with conflict detection and resolution |

### Template

The initialization template is located at:
```
skills/taskmanager/template/.taskmanager/
```

This template contains the initial structure for new projects including starter files.

---

## 1. Folder Layout

At the project root after initialization:

```text
.taskmanager/
  taskmanager.db                # SQLite database (all data)
  config.json                   # Project configuration (defaults, dashboard settings)
  backup-v1/                    # Migration backup (if migrated from JSON)
  backup-v2/                    # Migration backup (if migrated from v2)
  logs/
    activity.log                # Append-only log (errors and decisions)
  docs/
    prd.md                      # Project requirements document
    tasks/                      # Individual task files (generated by export --files)
```

### 1.2 Configuration

Project configuration is stored in `.taskmanager/config.json`. Commands should read this file for default values. Configuration can be overridden via command flags.

```json
{
  "version": "3.1.0",
  "defaults": {
    "priority": "medium",
    "type": "feature",
    "complexity_threshold_for_expansion": "M",
    "max_subtask_depth": 3
  },
  "dashboard": {
    "next_tasks_count": 5
  }
}
```

### 1.1 Token-Efficient Task Operations

SQLite enables efficient operations without loading all data into memory:

#### Using Commands

```bash
# Get statistics in JSON format
taskmanager:show --stats --json

# Get a specific task by ID
taskmanager:show 1.2.3
taskmanager:show 1.2.3 status
taskmanager:show 1.2.3 complexity_scale

# Update status for tasks
taskmanager:update 1.2.3 --status done
taskmanager:update 1.2.3,1.2.4,1.2.5 --status done
```

#### Using sqlite3 Directly

```bash
# Get statistics
sqlite3 .taskmanager/taskmanager.db "
SELECT COUNT(*) as total,
  SUM(CASE WHEN status='done' THEN 1 ELSE 0 END) as done
FROM tasks WHERE archived_at IS NULL"

# Get specific task as JSON
sqlite3 -json .taskmanager/taskmanager.db "
SELECT * FROM tasks WHERE id = '1.2.3'"

# Get next available task
sqlite3 -json .taskmanager/taskmanager.db "
SELECT * FROM tasks
WHERE status = 'planned' AND archived_at IS NULL
ORDER BY priority DESC, id
LIMIT 1"

# Update task status
sqlite3 .taskmanager/taskmanager.db "
UPDATE tasks SET status = 'done', completed_at = datetime('now')
WHERE id = '1.2.3'"
```

#### Benefits of SQLite:
- Indexed queries for instant lookups regardless of task count
- No file size limits or token concerns
- Atomic transactions prevent data corruption
- FTS5 full-text search for memories

Agents MUST:

* Use proper SQL queries to read/write data.
* Maintain referential integrity (parent_id references valid tasks).
* Write decisions and errors to `activity.log`.

Initialization of `.taskmanager/` SHOULD be done using:

```
taskmanager:init
```

---

## 2. Database Schema

All data is stored in `.taskmanager/taskmanager.db`, a SQLite database.

### 2.1 Database Tables

| Table | Purpose |
|-------|---------|
| `tasks` | All tasks (active and archived via `archived_at` column) |
| `memories` | Project memories with metadata |
| `memories_fts` | FTS5 virtual table for full-text search on memories |
| `deferrals` | Deferred work tracking with source/target task linkage |
| `state` | Single-row execution state |
| `schema_version` | Migration tracking |

### 2.2 Tasks Table Schema

```sql
CREATE TABLE tasks (
  id TEXT PRIMARY KEY,              -- Dotted ID pattern: "1", "1.2", "1.2.3"
  parent_id TEXT,                   -- Parent reference (NULL for top-level)
  title TEXT NOT NULL,
  description TEXT,
  details TEXT,
  test_strategy TEXT,               -- How to verify this task is complete
  status TEXT NOT NULL DEFAULT 'planned',
  type TEXT DEFAULT 'feature',
  priority TEXT DEFAULT 'medium',
  complexity_scale TEXT,            -- XS, S, M, L, XL
  complexity_reasoning TEXT,
  complexity_expansion_prompt TEXT,
  estimate_seconds INTEGER,
  duration_seconds INTEGER,
  owner TEXT,
  started_at TEXT,                  -- ISO 8601 timestamp
  completed_at TEXT,                -- ISO 8601 timestamp
  archived_at TEXT,                 -- ISO 8601 timestamp (NULL = active)
  tags TEXT DEFAULT '[]',           -- JSON array of strings
  dependencies TEXT DEFAULT '[]',   -- JSON array of task IDs
  dependency_analysis TEXT,
  meta TEXT DEFAULT '{}',           -- JSON object for extensibility
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (parent_id) REFERENCES tasks(id) ON DELETE CASCADE
);
```

**Status values:**
- `draft`, `planned`, `in-progress`, `blocked`, `paused`
- `done`, `canceled`, `duplicate`, `needs-review`

**Type values:**
- `feature`, `bug`, `chore`, `analysis`, `spike`

**Priority values:**
- `low`, `medium`, `high`, `critical`

### 2.3 Hierarchy Rules

* IDs are **unique** across all tasks.
* Dotted paths define hierarchy:

  * `"1"` → top level
  * `"1.2"` → second child of task 1
  * `"1.2.3"` → third child of task 1.2
* `parent_id` MUST:

  * Be `NULL` for top-level tasks
  * Match the actual parent's ID for subtasks

The hierarchy is enforced via foreign key constraint with `ON DELETE CASCADE`.

### 2.4 SQL Query Examples

```sql
-- Get all active (non-archived) tasks
SELECT * FROM tasks WHERE archived_at IS NULL;

-- Get task with children
SELECT * FROM tasks WHERE id = '1' OR parent_id = '1';

-- Get next available task (planned, no blockers)
SELECT * FROM tasks
WHERE status = 'planned'
  AND archived_at IS NULL
  AND (dependencies IS NULL OR dependencies = '[]')
ORDER BY
  CASE priority
    WHEN 'critical' THEN 1
    WHEN 'high' THEN 2
    WHEN 'medium' THEN 3
    WHEN 'low' THEN 4
  END,
  CASE complexity_scale
    WHEN 'XS' THEN 0
    WHEN 'S' THEN 1
    WHEN 'M' THEN 2
    WHEN 'L' THEN 3
    WHEN 'XL' THEN 4
    ELSE 2
  END,
  id
LIMIT 1;

-- Insert new task
INSERT INTO tasks (id, parent_id, title, status, type, priority)
VALUES ('1.3', '1', 'New subtask', 'planned', 'feature', 'medium');
```

### 2.5 Time & Estimation Invariants

  - `estimate_seconds`
    - Leaf tasks: SHOULD be non-null (>= 0) before execution.
    - Parent tasks: SHOULD equal the sum of `estimate_seconds` of their direct children.
  - `started_at` / `completed_at`
    - Set only by the runtime when a leaf task enters `"in-progress"` or a terminal state.
    - Stored as ISO 8601 UTC timestamps.
  - `duration_seconds`
    - Computed as `completed_at - started_at` in seconds, when a leaf becomes terminal.
    - Never negative; NULL if `started_at` was not set.

### 2.6 Archival

Archival is handled via the `archived_at` column - no separate table needed:

```sql
-- Archive a task
UPDATE tasks
SET archived_at = datetime('now')
WHERE id = '1.2.3';

-- Unarchive a task
UPDATE tasks
SET archived_at = NULL
WHERE id = '1.2.3';

-- Get only archived tasks
SELECT * FROM tasks WHERE archived_at IS NOT NULL;

-- Get only active tasks
SELECT * FROM tasks WHERE archived_at IS NULL;
```

**Archive invariants:**
- Tasks with `archived_at IS NOT NULL` are considered archived
- Archived tasks SHOULD have terminal status (`done`, `canceled`, `duplicate`)
- All task data remains intact (no stub/full split)

---

## 3. Memories Table

Project memories are stored in the `memories` table with FTS5 full-text search support.

### 3.1 Memories Table Schema

```sql
CREATE TABLE memories (
  id TEXT PRIMARY KEY,              -- Format: M-0001, M-0002, etc.
  title TEXT NOT NULL,
  kind TEXT NOT NULL                -- constraint, decision, bugfix, workaround, convention, architecture, process, integration, anti-pattern, other
    CHECK (kind IN ('constraint', 'decision', 'bugfix', 'workaround', 'convention', 'architecture', 'process', 'integration', 'anti-pattern', 'other')),
  why_important TEXT NOT NULL,
  body TEXT NOT NULL,
  source_type TEXT NOT NULL         -- user, agent, command, hook, other
    CHECK (source_type IN ('user', 'agent', 'command', 'hook', 'other')),
  source_name TEXT,
  source_via TEXT,
  auto_updatable INTEGER DEFAULT 1, -- 0 for user-created
  importance INTEGER NOT NULL DEFAULT 3 CHECK (importance BETWEEN 1 AND 5),
  confidence REAL NOT NULL DEFAULT 0.8 CHECK (confidence BETWEEN 0 AND 1),
  status TEXT NOT NULL DEFAULT 'active'
    CHECK (status IN ('active', 'deprecated', 'superseded', 'draft')),
  superseded_by TEXT REFERENCES memories(id),
  scope TEXT DEFAULT '{}',          -- JSON object
  tags TEXT DEFAULT '[]',           -- JSON array
  links TEXT DEFAULT '[]',          -- JSON array
  use_count INTEGER DEFAULT 0,
  last_used_at TEXT,
  last_conflict_at TEXT,
  conflict_resolutions TEXT DEFAULT '[]', -- JSON array
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);

-- FTS5 virtual table for full-text search
CREATE VIRTUAL TABLE memories_fts USING fts5(
  title, body, tags,
  content='memories',
  content_rowid='rowid'
);
```

**Purpose**

Capture long-lived project knowledge that should survive across sessions, tasks, and agents:

- Architectural and product decisions
- Invariants and constraints
- Common pitfalls, bugfixes, and workarounds
- Conventions, naming rules, testing rules
- Repeated errors and their resolutions

### 3.2 Memory Invariants

- IDs are stable (`M-0001`, `M-0002`, ...).
- `status = 'deprecated'` or `'superseded'` memories MUST NOT be deleted; they stay for history.
- `importance >= 4` memories SHOULD be considered whenever planning or executing high-impact tasks.
- `auto_updatable` MUST be `0` for user-created memories (`source_type = 'user'`).
- `conflict_resolutions` JSON array MUST record every conflict resolution with timestamp and reason.

### 3.3 Memory SQL Examples

```sql
-- Add a memory
INSERT INTO memories (id, title, kind, why_important, body, source_type, importance)
VALUES ('M-0001', 'Use snake_case for DB columns', 'convention', 'Consistency', 'Always use snake_case for database columns', 'user', 4);

-- Search memories using FTS5
SELECT m.* FROM memories m
JOIN memories_fts fts ON m.rowid = fts.rowid
WHERE memories_fts MATCH 'database AND convention';

-- Get active high-importance memories
SELECT * FROM memories
WHERE status = 'active' AND importance >= 4
ORDER BY importance DESC, use_count DESC;

-- Update usage tracking
UPDATE memories
SET use_count = use_count + 1, last_used_at = datetime('now')
WHERE id = 'M-0001';

-- Deprecate a memory
UPDATE memories
SET status = 'deprecated', updated_at = datetime('now')
WHERE id = 'M-0001';
```

### 3.4 Memory Scopes

There are two scopes of memory:

1. **Global Memory** (persisted in `memories` table):
   - Added via `--memory` / `-gm` command argument or `taskmanager:memory add` command.
   - Persists across all tasks and sessions.
   - User-created memories require user approval for any changes.

2. **Task-Scoped Memory** (stored in `state` table `task_memory` column):
   - Added via `--task-memory` / `-tm` command argument.
   - Temporary, lives only for duration of task or batch.
   - Reviewed for promotion to global at task completion.

### 3.5 Lifecycle

- **Creation**: When a user, agent, or command makes a decision that should apply to future work.
- **Update**: When a memory is refined, corrected, or superseded.
- **Conflict Detection**: Opt-in via `taskmanager:memory conflicts`.
- **Conflict Resolution**: Depends on ownership:
  - User-created (`source_type = 'user'`): ALWAYS requires user approval.
  - System-created: Can auto-update for refinements, requires approval for reversals.
- **Usage Tracking**: When applied to a task, `use_count` incremented and `last_used_at` updated.

---

## 4. Deferrals Table

Deferrals track work that was explicitly deferred from one task to another. They survive context loss because they live in the SQLite database and are automatically loaded during task execution.

### 4.1 Deferrals Table Schema

```sql
CREATE TABLE deferrals (
  id TEXT PRIMARY KEY,                -- Format: D-0001, D-0002, ...
  source_task_id TEXT NOT NULL REFERENCES tasks(id) ON DELETE RESTRICT,
  target_task_id TEXT REFERENCES tasks(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  reason TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'applied', 'reassigned', 'canceled')),
  applied_at TEXT,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);
```

**Status values:**
- `pending` — Work not yet addressed
- `applied` — Work was completed in the target task
- `reassigned` — Deferral moved to a different target (original closed, new one created)
- `canceled` — Deferred work is no longer needed

**FK behavior:**
- `source_task_id ON DELETE RESTRICT` — Cannot delete a task that has deferrals originating from it
- `target_task_id ON DELETE SET NULL` — If target task is deleted, deferral becomes unassigned (not lost)

### 4.2 Deferral Invariants

- IDs are stable (`D-0001`, `D-0002`, ...).
- Pending deferrals targeting a task MUST be surfaced before executing that task (see `run.md` Step 4).
- Pending deferrals MUST be resolved before marking a target task as terminal (see `run.md` Step 8a).
- When tasks are moved/re-IDed, deferral `source_task_id` and `target_task_id` MUST be updated.
- Deferrals are never deleted; they transition to `applied`, `reassigned`, or `canceled`.

### 4.3 Deferral SQL Examples

```sql
-- Create a deferral
INSERT INTO deferrals (id, source_task_id, target_task_id, title, body, reason)
VALUES ('D-0001', '1.2', '3.1', 'Add OAuth support', 'Implement OAuth2 with Google and GitHub', 'Too complex for MVP');

-- Get pending deferrals for a task
SELECT d.id, d.title, d.body, d.reason, d.source_task_id
FROM deferrals d
WHERE d.target_task_id = '3.1' AND d.status = 'pending'
ORDER BY d.created_at;

-- Mark deferral as applied
UPDATE deferrals SET status = 'applied', applied_at = datetime('now'), updated_at = datetime('now')
WHERE id = 'D-0001';

-- Get next deferral ID
SELECT 'D-' || printf('%04d', COALESCE(MAX(CAST(SUBSTR(id, 3) AS INTEGER)), 0) + 1)
FROM deferrals;

-- Dashboard aggregate
SELECT
    COUNT(*) as total_pending,
    SUM(CASE WHEN target_task_id IS NOT NULL THEN 1 ELSE 0 END) as assigned,
    SUM(CASE WHEN target_task_id IS NULL THEN 1 ELSE 0 END) as unassigned
FROM deferrals WHERE status = 'pending';
```

---

## 5. State Table

The `state` table stores execution state as a single row.

### 5.1 State Table Schema

```sql
CREATE TABLE state (
  id INTEGER PRIMARY KEY CHECK (id = 1),  -- Ensures single row
  current_task_id TEXT REFERENCES tasks(id),
  task_memory TEXT DEFAULT '[]',      -- JSON array of task-scoped memories
  debug_enabled INTEGER DEFAULT 0,
  session_id TEXT,
  started_at TEXT,
  last_update TEXT
);
```

### 5.2 State Fields

* `current_task_id` — string or NULL (the task being executed)
* `task_memory` — JSON array of task-scoped memories
* `debug_enabled` — integer (reserved, default 0)
* `session_id` — string or NULL (for log correlation)
* `started_at` — ISO 8601 timestamp
* `last_update` — ISO 8601 timestamp

### 5.3 Task Memory

`task_memory` JSON column stores temporary, task-scoped memories:

```json
[
  {
    "content": "Focus on error handling in this task",
    "addedAt": "2025-12-11T10:00:00Z",
    "taskId": "1.2.3",
    "source": "user"
  }
]
```

**Invariants**:
- `taskId` MUST be a valid task ID pattern OR `"*"` for batch-level memories.
- Cleared for each task at task completion (after promotion review).
- `"*"` task memories are cleared at batch completion.

### 5.4 SQL Examples

```sql
-- Get current state
SELECT * FROM state WHERE id = 1;

-- Update current task
UPDATE state SET
  current_task_id = '1.2.3',
  last_update = datetime('now')
WHERE id = 1;

-- Clear task memory after completion
UPDATE state SET
  task_memory = '[]',
  current_task_id = NULL,
  last_update = datetime('now')
WHERE id = 1;

-- Initialize state (done by init command)
INSERT OR REPLACE INTO state (id, started_at)
VALUES (1, datetime('now'));
```

---

## 6. Logs Contract

Logs live under:

```
.taskmanager/logs/
```

### 6.1 Log File

| File | Purpose | When to Write |
|------|---------|---------------|
| `activity.log` | All events: errors, decisions, status changes, memory operations | ALWAYS |

### 6.2 Logging Rules

* Logs are **append-only**. Never truncate or overwrite.
* All log entries MUST include an ISO 8601 timestamp.
* All log entries SHOULD include a command/source name for correlation.

### 6.3 Log Entry Format

```text
<timestamp> [<level>] [<command>] <message>
```

**Levels:**
- `ERROR` — Failures, exceptions, validation errors
- `DECISION` — Planning choices, task transitions, memory changes

**Examples:**

```text
2025-12-11T10:00:00Z [DECISION] [run] Started task 1.2.3: "Implement user auth"
2025-12-11T10:00:01Z [DECISION] [run] Applied memories: M-0001, M-0003
2025-12-11T10:00:02Z [ERROR] [memory] Conflict detected: M-0001 references deleted file app/OldAuth.php
2025-12-11T10:05:00Z [DECISION] [run] Completed task 1.2.3 with status "done"
```

### 6.4 What to Log

- SQL errors and constraint violations
- Database connection failures
- Task creation (from planning)
- Task status transitions (planned -> in-progress -> done)
- Memory creation, update, deprecation, supersession
- Memory application (which memories applied to which task)
- Conflict resolution outcomes
- Batch start/end summaries
- Dependency resolution failures
- Deferral creation, resolution, reassignment

---

## 7. Schema Version Table

```sql
CREATE TABLE schema_version (
  version TEXT PRIMARY KEY,
  applied_at TEXT DEFAULT (datetime('now'))
);
```

Current version: `3.1.0`.

---

## 8. Interop Rules (Very Important)

All planning, execution, dashboard, next-task, and other features must:

1. Treat this document as the **contract** for:

   * `taskmanager.db` SQLite database
   * Tables: `tasks`, `memories`, `memories_fts`, `deferrals`, `state`, `schema_version`
   * Logging rules
2. Use proper SQL queries to read/write data
3. Delegate all behavior to the plugin's skills and commands:

   * `taskmanager` skill — task management behavior
   * `taskmanager-memory` skill — memory management behavior
   * Plugin commands — command implementations

4. For deferral operations:

   * Load pending deferrals before executing a target task
   * Create deferral records when work is explicitly deferred
   * Resolve all pending deferrals before marking a task as terminal
   * Update deferral references when tasks are moved/re-IDed

5. For memory operations:

   * Use the `taskmanager-memory` skill for all memory management
   * Use FTS5 search via `memories_fts` table for content matching
   * Conflict detection is opt-in via `taskmanager:memory conflicts`
   * Always ask user for approval when modifying user-created memories
   * Review task-scoped memories for promotion before marking task as done

This file is intentionally **behavior-light**.
Its purpose is to define *what the data must look like*, not how tasks are planned or executed.

---

## 9. Command Reference

All commands are documented in their individual `.md` files under `commands/`. See the commands table in section "Plugin Resources" above for the full list.
